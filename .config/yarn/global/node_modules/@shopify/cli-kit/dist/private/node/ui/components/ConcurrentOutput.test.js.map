{"version":3,"file":"ConcurrentOutput.test.js","sourceRoot":"","sources":["../../../../../src/private/node/ui/components/ConcurrentOutput.test.tsx"],"names":[],"mappings":"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","sourcesContent":["import {ConcurrentOutput} from './ConcurrentOutput.js'\nimport {getLastFrameAfterUnmount, waitForInputsToBeReady, render, Stdin} from '../../testing/ui.js'\nimport {AbortController, AbortSignal} from '../../../../public/node/abort.js'\nimport {unstyled} from '../../../../public/node/output.js'\nimport React from 'react'\nimport {describe, expect, test, vi} from 'vitest'\nimport {Writable} from 'stream'\n\ndescribe('ConcurrentOutput', () => {\n  test('renders a stream of concurrent outputs from sub-processes', async () => {\n    // Given\n    let backendPromiseResolve: () => void\n    let frontendPromiseResolve: () => void\n\n    const backendPromise = new Promise<void>(function (resolve, _reject) {\n      backendPromiseResolve = resolve\n    })\n\n    const frontendPromise = new Promise<void>(function (resolve, _reject) {\n      frontendPromiseResolve = resolve\n    })\n\n    const backendProcess = {\n      prefix: 'backend',\n      action: async (stdout: Writable, _stderr: Writable, _signal: AbortSignal) => {\n        stdout.write('first backend message')\n        stdout.write('second backend message')\n        stdout.write('third backend message')\n\n        backendPromiseResolve()\n      },\n    }\n\n    const frontendProcess = {\n      prefix: 'frontend',\n      action: async (stdout: Writable, _stderr: Writable, _signal: AbortSignal) => {\n        await backendPromise\n\n        stdout.write('first frontend message')\n        stdout.write('second frontend message')\n        stdout.write('third frontend message')\n\n        frontendPromiseResolve()\n\n        // await promise that never resolves\n        await new Promise(() => {})\n      },\n    }\n    // When\n\n    const renderInstance = render(\n      <ConcurrentOutput\n        processes={[backendProcess, frontendProcess]}\n        abortSignal={new AbortController().signal}\n        footer={{\n          shortcuts: [\n            {\n              key: 'p',\n              action: 'preview in your browser',\n            },\n            {\n              key: 'q',\n              action: 'quit',\n            },\n          ],\n          subTitle: `Preview URL: https://shopify.com`,\n        }}\n      />,\n    )\n\n    await frontendPromise\n\n    // Then\n    expect(unstyled(renderInstance.lastFrame()!.replace(/\\d/g, '0'))).toMatchInlineSnapshot(`\n      \"0000-00-00 00:00:00 │ backend  │ first backend message\n      0000-00-00 00:00:00 │ backend  │ second backend message\n      0000-00-00 00:00:00 │ backend  │ third backend message\n      0000-00-00 00:00:00 │ frontend │ first frontend message\n      0000-00-00 00:00:00 │ frontend │ second frontend message\n      0000-00-00 00:00:00 │ frontend │ third frontend message\n\n      › Press p │ preview in your browser\n      › Press q │ quit\n\n      Preview URL: https://shopify.com\n      \"\n    `)\n  })\n\n  test(\"doesn't render shortcuts if the stdin is not a TTY\", async () => {\n    // Given\n    let backendPromiseResolve: () => void\n    let frontendPromiseResolve: () => void\n\n    const backendPromise = new Promise<void>(function (resolve, _reject) {\n      backendPromiseResolve = resolve\n    })\n\n    const frontendPromise = new Promise<void>(function (resolve, _reject) {\n      frontendPromiseResolve = resolve\n    })\n\n    const backendProcess = {\n      prefix: 'backend',\n      action: async (stdout: Writable, _stderr: Writable, _signal: AbortSignal) => {\n        stdout.write('first backend message')\n        stdout.write('second backend message')\n        stdout.write('third backend message')\n\n        backendPromiseResolve()\n      },\n    }\n\n    const frontendProcess = {\n      prefix: 'frontend',\n      action: async (stdout: Writable, _stderr: Writable, _signal: AbortSignal) => {\n        await backendPromise\n\n        stdout.write('first frontend message')\n        stdout.write('second frontend message')\n        stdout.write('third frontend message')\n\n        frontendPromiseResolve()\n\n        // await promise that never resolves\n        await new Promise(() => {})\n      },\n    }\n    // When\n\n    const renderInstance = render(\n      <ConcurrentOutput\n        processes={[backendProcess, frontendProcess]}\n        abortSignal={new AbortController().signal}\n        footer={{\n          shortcuts: [\n            {\n              key: 'p',\n              action: 'preview in your browser',\n            },\n            {\n              key: 'q',\n              action: 'quit',\n            },\n          ],\n          subTitle: `Preview URL: https://shopify.com`,\n        }}\n      />,\n      {stdin: new Stdin({isTTY: false})},\n    )\n\n    await frontendPromise\n\n    // Then\n    expect(unstyled(getLastFrameAfterUnmount(renderInstance)!.replace(/\\d/g, '0'))).toMatchInlineSnapshot(`\n      \"0000-00-00 00:00:00 │ backend  │ first backend message\n      0000-00-00 00:00:00 │ backend  │ second backend message\n      0000-00-00 00:00:00 │ backend  │ third backend message\n      0000-00-00 00:00:00 │ frontend │ first frontend message\n      0000-00-00 00:00:00 │ frontend │ second frontend message\n      0000-00-00 00:00:00 │ frontend │ third frontend message\n\n      Preview URL: https://shopify.com\n      \"\n    `)\n  })\n\n  test('accepts a onInput function that fires when a key is pressed', async () => {\n    const neverEndingPromise = new Promise<void>(function (_resolve, _reject) {})\n\n    const neverEndingProcess = {\n      prefix: 'never-ending-process',\n      action: async () => {\n        await neverEndingPromise\n      },\n    }\n\n    const onInput = vi.fn()\n\n    const renderInstance = render(\n      <ConcurrentOutput\n        processes={[neverEndingProcess]}\n        onInput={(input, key) => onInput(input, key)}\n        abortSignal={new AbortController().signal}\n      />,\n    )\n\n    await waitForInputsToBeReady()\n    expect(onInput).toHaveBeenCalledTimes(0)\n\n    renderInstance.stdin.write('a')\n    expect(onInput).toHaveBeenCalledTimes(1)\n    expect(onInput.mock.calls[0]![0]).toBe('a')\n  })\n\n  test('abortController can be used to exit from outside and should preserve static output', async () => {\n    // Given\n    const abortController = new AbortController()\n\n    const backendProcess = {\n      prefix: 'backend',\n      action: async (stdout: Writable, _stderr: Writable, _signal: AbortSignal) => {\n        stdout.write('first backend message')\n        stdout.write('second backend message')\n        stdout.write('third backend message')\n\n        // await promise that never resolves\n        await new Promise(() => {})\n      },\n    }\n\n    // When\n\n    const renderInstance = render(\n      <ConcurrentOutput\n        processes={[backendProcess]}\n        abortSignal={abortController.signal}\n        footer={{\n          shortcuts: [\n            {\n              key: 'p',\n              action: 'preview in your browser',\n            },\n            {\n              key: 'q',\n              action: 'quit',\n            },\n          ],\n          subTitle: `Preview URL: https://shopify.com`,\n        }}\n      />,\n    )\n\n    const promise = renderInstance.waitUntilExit()\n\n    abortController.abort()\n\n    expect(unstyled(getLastFrameAfterUnmount(renderInstance)!).replace(/\\d/g, '0')).toMatchInlineSnapshot(`\n      \"0000-00-00 00:00:00 │ backend │ first backend message\n      0000-00-00 00:00:00 │ backend │ second backend message\n      0000-00-00 00:00:00 │ backend │ third backend message\n\n      Preview URL: https://shopify.com\n      \"\n    `)\n\n    await expect(promise).resolves.toEqual(undefined)\n  })\n\n  test('rejects with the error thrown inside one of the processes', async () => {\n    // Given\n    const backendProcess = {\n      prefix: 'backend',\n      action: async (stdout: Writable, _stderr: Writable, _signal: AbortSignal) => {\n        stdout.write('first backend message')\n        stdout.write('second backend message')\n        stdout.write('third backend message')\n\n        throw new Error('something went wrong')\n      },\n    }\n\n    // When\n\n    const renderInstance = render(\n      <ConcurrentOutput\n        processes={[backendProcess]}\n        abortSignal={new AbortController().signal}\n        footer={{\n          shortcuts: [\n            {\n              key: 'p',\n              action: 'preview in your browser',\n            },\n            {\n              key: 'q',\n              action: 'quit',\n            },\n          ],\n          subTitle: `Preview URL: https://shopify.com`,\n        }}\n      />,\n    )\n\n    await expect(renderInstance.waitUntilExit()).rejects.toThrowError('something went wrong')\n\n    expect(unstyled(getLastFrameAfterUnmount(renderInstance)!).replace(/\\d/g, '0')).toMatchInlineSnapshot(`\n      \"0000-00-00 00:00:00 │ backend │ first backend message\n      0000-00-00 00:00:00 │ backend │ second backend message\n      0000-00-00 00:00:00 │ backend │ third backend message\n\n      Preview URL: https://shopify.com\n      \"\n    `)\n  })\n\n  test(\"doesn't render the shortcuts when the processes resolve\", async () => {\n    // Given\n    const backendProcess = {\n      prefix: 'backend',\n      action: async (stdout: Writable, _stderr: Writable, _signal: AbortSignal) => {\n        stdout.write('first backend message')\n        stdout.write('second backend message')\n        stdout.write('third backend message')\n      },\n    }\n\n    // When\n\n    const renderInstance = render(\n      <ConcurrentOutput\n        processes={[backendProcess]}\n        abortSignal={new AbortController().signal}\n        footer={{\n          shortcuts: [\n            {\n              key: 'p',\n              action: 'preview in your browser',\n            },\n            {\n              key: 'q',\n              action: 'quit',\n            },\n          ],\n          subTitle: `Preview URL: https://shopify.com`,\n        }}\n      />,\n    )\n\n    await renderInstance.waitUntilExit()\n\n    expect(unstyled(getLastFrameAfterUnmount(renderInstance)!).replace(/\\d/g, '0')).toMatchInlineSnapshot(`\n      \"0000-00-00 00:00:00 │ backend │ first backend message\n      0000-00-00 00:00:00 │ backend │ second backend message\n      0000-00-00 00:00:00 │ backend │ third backend message\n\n      Preview URL: https://shopify.com\n      \"\n    `)\n  })\n})\n"]}