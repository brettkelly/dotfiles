{"version":3,"file":"error.js","sourceRoot":"","sources":["../../../src/public/node/error.ts"],"names":[],"mappings":"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","sourcesContent":["import {AlertCustomSection, renderFatalError} from './ui.js'\nimport {OutputMessage, stringifyMessage, TokenizedString} from '../../public/node/output.js'\nimport {normalizePath} from '../../public/node/path.js'\nimport {InlineToken, TokenItem, tokenItemToString} from '../../private/node/ui/components/TokenizedText.js'\nimport {Errors} from '@oclif/core'\n\nexport {ExtendableError} from 'ts-error'\n\nexport enum FatalErrorType {\n  Abort,\n  AbortSilent,\n  Bug,\n}\n\nexport class CancelExecution extends Error {}\n\n/**\n * A fatal error represents an error shouldn't be rescued and that causes the execution to terminate.\n * There shouldn't be code that catches fatal errors.\n */\nexport abstract class FatalError extends Error {\n  tryMessage: TokenItem | null\n  type: FatalErrorType\n  nextSteps?: TokenItem<InlineToken>[]\n  formattedMessage?: TokenItem\n  customSections?: AlertCustomSection[]\n  /**\n   * Creates a new FatalError error.\n   *\n   * @param message - The error message.\n   * @param type - The type of fatal error.\n   * @param tryMessage - The message that recommends next steps to the user.\n   * You can pass a string a {@link TokenizedString} or a {@link TokenItem}\n   * if you need to style the message inside the error Banner component.\n   * @param nextSteps - Message to show as \"next steps\" with suggestions to solve the issue.\n   * @param customSections - Custom sections to show in the error banner. To be used if nextSteps is not enough.\n   */\n  constructor(\n    message: TokenItem | OutputMessage,\n    type: FatalErrorType,\n    tryMessage: TokenItem | OutputMessage | null = null,\n    nextSteps?: TokenItem<InlineToken>[],\n    customSections?: AlertCustomSection[],\n  ) {\n    const messageIsOutputMessage = typeof message === 'string' || 'value' in message\n    super(messageIsOutputMessage ? stringifyMessage(message) : tokenItemToString(message))\n\n    if (tryMessage) {\n      if (tryMessage instanceof TokenizedString) {\n        this.tryMessage = stringifyMessage(tryMessage)\n      } else {\n        this.tryMessage = tryMessage\n      }\n    } else {\n      this.tryMessage = null\n    }\n\n    this.type = type\n    this.nextSteps = nextSteps\n    this.customSections = customSections\n\n    if (!messageIsOutputMessage) {\n      this.formattedMessage = message\n    }\n  }\n}\n\n/**\n * An abort error is a fatal error that shouldn't be reported as a bug.\n * Those usually represent unexpected scenarios that we can't handle and that usually require some action from the developer.\n */\nexport class AbortError extends FatalError {\n  nextSteps?: TokenItem<InlineToken>[]\n  customSections?: AlertCustomSection[]\n  constructor(\n    message: TokenItem | OutputMessage,\n    tryMessage: TokenItem | OutputMessage | null = null,\n    nextSteps?: TokenItem<InlineToken>[],\n    customSections?: AlertCustomSection[],\n  ) {\n    super(message, FatalErrorType.Abort, tryMessage, nextSteps, customSections)\n  }\n}\n\n/**\n * An external error is similar to Abort but has extra command and args attributes.\n * This is useful to represent errors coming from external commands, usually executed by execa.\n */\nexport class ExternalError extends FatalError {\n  command: string\n  args: string[]\n\n  constructor(\n    message: OutputMessage,\n    command: string,\n    args: string[],\n    tryMessage: TokenItem | OutputMessage | null = null,\n  ) {\n    super(message, FatalErrorType.Abort, tryMessage)\n    this.command = command\n    this.args = args\n  }\n}\n\nexport class AbortSilentError extends FatalError {\n  constructor() {\n    super('', FatalErrorType.AbortSilent)\n  }\n}\n\n/**\n * A bug error is an error that represents a bug and therefore should be reported.\n */\nexport class BugError extends FatalError {\n  constructor(message: OutputMessage, tryMessage: TokenItem | null = null) {\n    super(message, FatalErrorType.Bug, tryMessage)\n  }\n}\n\n/**\n * A function that handles errors that blow up in the CLI.\n *\n * @param error - Error to be handled.\n * @returns A promise that resolves with the error passed.\n */\nexport async function handler(error: unknown): Promise<unknown> {\n  let fatal: FatalError\n  if (isFatal(error)) {\n    fatal = error\n  } else if (typeof error === 'string') {\n    fatal = new BugError(error)\n  } else if (error instanceof Error) {\n    fatal = new BugError(error.message)\n    fatal.stack = error.stack\n  } else {\n    // errors can come in all shapes and sizes...\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const maybeError = error as any\n    fatal = new BugError(maybeError?.message ?? 'Unknown error')\n    if (maybeError?.stack) {\n      fatal.stack = maybeError?.stack\n    }\n  }\n\n  renderFatalError(fatal)\n  return Promise.resolve(error)\n}\n\n/**\n * A function that maps an error to an Abort with the stack trace when coming from the CLI.\n *\n * @param error - Error to be mapped.\n * @returns A promise that resolves with the new error object.\n */\nexport function errorMapper(error: unknown): Promise<unknown> {\n  if (error instanceof Errors.CLIError) {\n    const mappedError = new AbortError(error.message)\n    mappedError.stack = error.stack\n    return Promise.resolve(mappedError)\n  } else {\n    return Promise.resolve(error)\n  }\n}\n\n/**\n * A function that checks if an error is a fatal one.\n *\n * @param error - Error to be checked.\n * @returns A boolean indicating if the error is a fatal one.\n */\nfunction isFatal(error: unknown): error is FatalError {\n  try {\n    return Object.prototype.hasOwnProperty.call(error, 'type')\n    // eslint-disable-next-line no-catch-all/no-catch-all\n  } catch {\n    return false\n  }\n}\n\n/**\n * A function that checks if an error should be reported.\n *\n * @param error - Error to be checked.\n * @returns A boolean indicating if the error should be reported.\n */\nexport function shouldReportError(error: unknown): boolean {\n  if (!isFatal(error)) {\n    return true\n  }\n  if (error.type === FatalErrorType.Bug) {\n    return true\n  }\n  return false\n}\n\n/**\n * Stack traces usually have file:// - we strip that and also remove the Windows drive designation.\n *\n * @param filePath - Path to be cleaned.\n * @returns The cleaned path.\n */\nexport function cleanSingleStackTracePath(filePath: string): string {\n  return normalizePath(filePath)\n    .replace('file:/', '/')\n    .replace(/^\\/?[A-Z]:/, '')\n}\n"]}